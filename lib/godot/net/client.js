// Generated by CoffeeScript 1.6.3
(function() {
  var Client, back, clone, dgram, events, ip, jsonStream, log, net, noop, tls, utile, utils, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  events = require("events");

  dgram = require("dgram");

  net = require("net");

  tls = require("tls");

  back = require("back");

  ip = require("ip");

  uuid = require("node-uuid");

  utile = require("utile");

  utils = require("../common/utils");

  jsonStream = require("json-stream");

  log = utils.log;

  noop = utils.noop;

  clone = utile.clone;

  Client = (function(_super) {
    __extends(Client, _super);

    Client.prototype.validTypes = ["tcp", "tls", "udp", "unix"];

    Client.prototype.validSettings = ["type", "host", "port", "path", "reconnect", "format"];

    Client.prototype.validFormats = ["json"];

    Client.prototype.validate = function(options) {
      var _ref, _ref1;
      if (_ref = options != null ? options.type : void 0, __indexOf.call(this.validTypes, _ref) < 0) {
        return "Cannot create server without type: " + (this.validTypes.join(', '));
      }
      if (_ref1 = options.format, __indexOf.call(this.validFormats, _ref1) < 0) {
        return "Cannot create server without format: " + (this.validFormats.join(', '));
      }
      if (!(!options.reconnect || typeof options.reconnect === "object")) {
        return "Reconnect must be a defined object if used";
      }
    };

    function Client(options) {
      this._sendOverUDP = __bind(this._sendOverUDP, this);
      this.respond = __bind(this.respond, this);
      this.socketError = __bind(this.socketError, this);
      this.back = __bind(this.back, this);
      this._writeWhenAvailable = __bind(this._writeWhenAvailable, this);
      var err, key, producer, _i, _j, _len, _len1, _ref, _ref1;
      err = this.validate(options);
      if (err) {
        throw new Error(err);
      }
      events.EventEmitter.call(this);
      this.producers = {};
      this.handlers = {
        data: {},
        end: {}
      };
      _ref = this.validSettings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        this[key] = options[key];
      }
      this.host || (this.host = "0.0.0.0");
      this._producers = options.producers;
      this.attempt = null;
      this.defaults = {
        host: ip.address(),
        state: "ok",
        description: "No Description",
        tags: [],
        metric: 1,
        meta: {},
        ttl: 15000
      };
      if (Array.isArray(this._producers)) {
        _ref1 = this._producers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          producer = _ref1[_j];
          this.add(producer);
        }
      }
    }

    Client.prototype._writeWhenAvailable = function(data) {
      if (!this.socket) {
        return;
      }
      this.write(data);
    };

    Client.prototype.add = function(producer) {
      var id;
      id = producer.id || (producer.id = uuid.v4());
      this.producers[id] = producer;
      producer.on("data", this.handlers.data[id] = this._writeWhenAvailable);
      producer.on("end", this.handlers.end[id] = (function(_this) {
        return function() {
          return _this.remove(producer, id);
        };
      })(this));
      return this;
    };

    Client.prototype.remove = function(producer, id) {
      if (id == null) {
        id = producer.id;
      }
      producer.removeListener("data", this.handlers.data[id]);
      producer.removeListener("end", this.handlers.end[id]);
      delete this.producers[id];
      delete this.handlers.data[id];
      delete this.handlers.end[id];
      return this;
    };

    Client.prototype.argError = function() {
      var err;
      err = new Error("" + arg + " is required to connect");
      if (this.callback) {
        return this.callback(err);
      }
      return this.emit("error", err);
    };

    Client.prototype.parseArgs = function(port, host, callback) {
      var arg, _i, _len;
      this.callback = null;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        switch (typeof arg) {
          case "number":
            port = arg;
            break;
          case "string":
            host = arg;
            break;
          case "function":
            this.callback = arg;
        }
      }
      this.callback || (this.callback = noop);
      switch (this.type) {
        case "tcp":
        case "tls":
        case "udp":
          if (port) {
            this.port = port;
          }
          if (!this.port) {
            return "port";
          }
          if (host) {
            this.host = host;
          }
          break;
        case "unix":
          this.path = host;
          if (!this.path) {
            return "path";
          }
      }
    };

    Client.prototype._reconnect = function(err) {
      this.attempt || (this.attempt = clone(this.reconnect));
      this._lastErr = err;
      if (!this.terminate) {
        return back(this.back, this.attempt);
      }
    };

    Client.prototype.fail = function() {
      this.terminate = true;
      this.attempt = null;
      return this.emit("error", this._lastErr);
    };

    Client.prototype.back = function(fail, backoff) {
      if (fail) {
        return this.fail();
      }
      this.emit("reconnect", backoff);
      return this.connect();
    };

    Client.prototype.socketError = function(err) {
      if (this.reconnect) {
        return this._reconnect(err);
      } else {
        return this.emit("error", err);
      }
    };

    Client.prototype.respond = function() {
      this.terminate = false;
      this.emit("connect");
    };

    Client.prototype.connect = function(port, host, callback) {
      var err;
      err = this.parseArgs.apply(this, arguments);
      if (err) {
        return this.argError(err);
      }
      switch (this.type) {
        case "tcp":
          this.socket = net.connect({
            port: this.port,
            host: this.host
          }, this.callback);
          break;
        case "tls":
          this.socket = tls.connect({
            port: this.port,
            host: this.host
          }, this.callback);
          break;
        case "udp":
          this.socket = dgram.createSocket("udp4");
          process.nextTick(this.callback);
          break;
        case "unix":
          this.socket = net.connect({
            path: this.path
          }, this.callback);
      }
      this.socket.on("error", this.socketError);
      this.socket.on("connect", this.respond);
      return this;
    };

    Client.prototype.close = function() {
      var producer, _i, _len, _ref;
      this.socket.on("close", (function(_this) {
        return function() {
          return _this.emit("close");
        };
      })(this));
      switch (this.type) {
        case "tcp":
        case "tls":
        case "unix":
          this.socket.destroy();
          break;
        default:
          this.socket.close();
      }
      _ref = this.producers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        producer = _ref[_i];
        this.remove(producer);
      }
      return this;
    };

    Client.prototype.createSerializer = function() {
      switch (this.format) {
        case "json":
          return jsonStream.stringify();
      }
    };

    Client.prototype._sendOverUDP = function(chunk) {
      return this.socket.send(chunk, 0, chunk.length, this.port, this.host);
    };

    Client.prototype.write = function(data) {
      var serializer;
      if (!this.socket) {
        return;
      }
      serializer = this.createSerializer();
      switch (this.type) {
        case "tcp":
        case "tls":
        case "unix":
          serializer.pipe(this.socket, {
            end: false
          });
          break;
        case "udp":
          serializer.once("data", this._sendOverUDP);
      }
      serializer.write(data);
      serializer.end();
      return this;
    };

    Client.prototype.produce = function(data) {
      var defaultify;
      defaultify = function(obj) {
        return Object.keys(this.defaults).reduce((function(acc, key) {
          if (!acc[key]) {
            acc[key] = this.defaults[key];
          }
          return acc;
        }), obj);
      };
      this.defaults["time"] = Date.now();
      data = (Array.isArray(data) ? data.map(defaultify) : defaultify(data));
      return this.write(data);
    };

    return Client;

  })(events.EventEmitter);

  module.exports = Client;

}).call(this);
