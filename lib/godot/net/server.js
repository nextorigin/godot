// Generated by CoffeeScript 1.6.3
(function() {
  var ReadWriteStream, Server, Socket, common, dgram, events, jsonStream, log, net, tls, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  dgram = require("dgram");

  events = require("events");

  net = require("net");

  tls = require("tls");

  jsonStream = require("json-stream");

  uuid = require("node-uuid");

  Socket = require("./socket");

  common = require("../common");

  ReadWriteStream = common.ReadWriteStream;

  log = require("../common/utils").log;

  Server = (function(_super) {
    __extends(Server, _super);

    Server.prototype.validTypes = ["tcp", "tls", "udp", "unix"];

    Server.prototype.validSettings = ["type", "host", "port", "path", "multiplex", "format"];

    Server.prototype.validFormats = ["json"];

    Server.prototype.validate = function(options) {
      var _ref, _ref1;
      if (_ref = options != null ? options.type : void 0, __indexOf.call(this.validTypes, _ref) < 0) {
        return "Cannot create server without type: " + (this.validTypes.join(', '));
      }
      if (_ref1 = options.format, __indexOf.call(this.validFormats, _ref1) < 0) {
        return "Cannot create server without format: " + (this.validFormats.join(', '));
      }
    };

    function Server(options) {
      this._onUnixSocket = __bind(this._onUnixSocket, this);
      this._onTcpSocket = __bind(this._onTcpSocket, this);
      this._onUdpMessage = __bind(this._onUdpMessage, this);
      this.createReactor = __bind(this.createReactor, this);
      this.respond = __bind(this.respond, this);
      var err, key, reactor, _i, _j, _len, _len1, _ref, _ref1;
      err = this.validate(options);
      if (err) {
        throw new Error(err);
      }
      events.EventEmitter.call(this);
      this.reactors = {};
      this.hosts = {};
      _ref = this.validSettings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        this[key] = options[key];
      }
      this.host || (this.host = "0.0.0.0");
      if (this.multiplex == null) {
        this.multiplex = true;
      }
      this._reactors = options.reactors;
      log("initalizing " + (this.multiplex ? 'multiplex ' : '') + "godot server");
      if (Array.isArray(this._reactors)) {
        _ref1 = this._reactors;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          reactor = _ref1[_j];
          this.add(reactor);
        }
      }
      if (!this.multiplex) {
        this.createReactors("default");
      }
    }

    Server.prototype.add = function(reactor) {
      var key, keys, _i, _len, _results;
      this.emit("add", reactor);
      reactor.id || (reactor.id = uuid.v4());
      log("adding reactor " + reactor.id);
      this.reactors[reactor.id] = reactor;
      keys = Object.keys(this.hosts);
      if (keys.length) {
        if (this.multiplex) {
          _results = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            _results.push(this.hosts[key].push(this.createReactor(reactor.id)));
          }
          return _results;
        } else {
          return this.hosts["default"].push(this.createReactor(reactor.id));
        }
      }
    };

    Server.prototype.remove = function(reactor) {
      this.emit("remove", reactor);
      this.reactors[reactor.id].socket.removeAllListeners();
      delete this.reactors[reactor.id];
      return this;
    };

    Server.prototype.argError = function(arg) {
      var err;
      err = new Error("" + arg + " is required to listen");
      if (this.callback) {
        return this.callback(err);
      }
      return this.emit("error", err);
    };

    Server.prototype.parseArgs = function(port, host, callback) {
      var arg, _i, _len;
      this.callback = null;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        switch (typeof arg) {
          case "number":
            port = arg;
            break;
          case "string":
            host = arg;
            break;
          case "function":
            this.callback = arg;
        }
      }
      switch (this.type) {
        case "tcp":
        case "tls":
        case "udp":
          if (port) {
            this.port = port;
          }
          if (!this.port) {
            return "port";
          }
          if (host) {
            this.host = host;
          }
          break;
        case "unix":
          this.path = host;
          if (!this.path) {
            return "path";
          }
      }
    };

    Server.prototype.respond = function(err) {
      var responded;
      if (responded) {
        return;
      }
      this.server.removeListener("error", this.respond);
      this.server.removeListener("listening", this.respond);
      responded = true;
      if (!err) {
        this.emit("listening");
      }
      if (this.callback) {
        return this.callback(err);
      }
      if (err) {
        this.emit("error", err);
      }
      return responded = false;
    };

    Server.prototype.listen = function(port, host, callback) {
      var err;
      err = this.parseArgs.apply(this, arguments);
      if (err) {
        return this.argError(err);
      }
      switch (this.type) {
        case "tcp":
          this.server = net.createServer(this._onTcpSocket);
          this.server.once("error", this.respond);
          this.server.listen(this.port, this.host, this.respond);
          break;
        case "tls":
          this.server = tls.createServer(this._onTcpSocket);
          this.server.once("error", this.respond);
          this.server.listen(this.port, this.host, this.respond);
          break;
        case "udp":
          this.server = dgram.createSocket("udp4", this._onUdpMessage);
          this.server.once("listening", this.respond);
          this.server.once("error", this.respond);
          this.server.bind(this.port, this.host);
          break;
        case "unix":
          this.server = net.createServer(this._onUnixSocket);
          this.server.once("error", this.respond);
          this.server.listen(this.path, this.respond);
      }
      return this;
    };

    Server.prototype.close = function(callback) {
      switch (this.type) {
        case "tcp":
        case "tls":
        case "unix":
          this.server.close(callback);
          break;
        default:
          this.server.close();
      }
      return this;
    };

    Server.prototype.createReactor = function(id) {
      var socket;
      log("creating reactor for " + id);
      socket = new Socket;
      return {
        socket: socket,
        reactor: this.reactors[id](socket)
      };
    };

    Server.prototype.createReactors = function(id) {
      var key, val;
      if (this.hosts[id]) {
        return;
      }
      log("creating reactors for " + id);
      if (this.hosts["default"] && !this.multiplex) {
        this.hosts[id] = this.hosts["default"];
        return this;
      }
      this.hosts[id] = (function() {
        var _ref, _results;
        _ref = this.reactors;
        _results = [];
        for (key in _ref) {
          val = _ref[key];
          _results.push(this.createReactor(key));
        }
        return _results;
      }).call(this);
      return this;
    };

    Server.prototype.createParser = function() {
      switch (this.format) {
        case "json":
          return jsonStream.parse();
      }
    };

    Server.prototype.tellReactors = function(id, msg) {
      var reactor, _i, _len, _ref, _results;
      _ref = this.hosts[id];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        reactor = _ref[_i];
        _results.push(reactor.socket.write(msg));
      }
      return _results;
    };

    Server.prototype.decode = function(id, socket) {
      var parser,
        _this = this;
      parser = this.createParser();
      this.createReactors(id);
      parser.on("data", function(event) {
        return _this.tellReactors(id, msg);
      });
      socket.setEncoding("utf8");
      socket.pipe(parser);
    };

    Server.prototype._onUdpMessage = function(msg, rinfo) {
      var address, id, port;
      address = rinfo.address;
      port = rinfo.port;
      id = address + ":" + port;
      this.createReactors(id);
      msg = JSON.parse(msg.toString().replace("\n", ""));
      this.tellReactors(id, msg);
    };

    Server.prototype._onTcpSocket = function(socket) {
      var address, id, port;
      address = socket.remoteAddress;
      port = socket.remotePort;
      id = address + ":" + port;
      return this.decode(id, socket);
    };

    Server.prototype._onUnixSocket = function(socket) {
      return this.decode(this.path, socket);
    };

    return Server;

  })(events.EventEmitter);

  module.exports = Server;

}).call(this);
